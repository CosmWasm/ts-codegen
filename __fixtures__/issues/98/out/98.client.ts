/**
* This file was automatically generated by @abstract-money/ts-codegen@latest.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @abstract-money/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint128, InstantiateMsg, Coin, ExecuteMsg, InstallableExecMsg, Binary, ExecMsg, QueryMsg, InstallableQueryMsg, QueryMsg1, ConfigResponse, NullablePlugin, CanonicalAddr, Plugin, PluginsResponse } from "./98.types";
export interface 98ReadOnlyInterface {
  contractAddress: string;
  getConfig: () => Promise<ConfigResponse>;
  getPlugins: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PluginsResponse>;
  getPluginById: ({
    id
  }: {
    id: number;
  }) => Promise<NullablePlugin>;
}
export class 98QueryClient implements 98ReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getConfig = this.getConfig.bind(this);
    this.getPlugins = this.getPlugins.bind(this);
    this.getPluginById = this.getPluginById.bind(this);
  }

  getConfig = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_config: {}
    });
  };
  getPlugins = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PluginsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_plugins: {
        limit,
        start_after: startAfter
      }
    });
  };
  getPluginById = async ({
    id
  }: {
    id: number;
  }): Promise<NullablePlugin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_plugin_by_id: {
        id
      }
    });
  };
}
export interface 98Interface extends 98ReadOnlyInterface {
  contractAddress: string;
  sender: string;
  proxyInstallPlugin: ({
    id,
    instantiateMsg
  }: {
    id: number;
    instantiateMsg: Binary;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  registerPlugin: ({
    checksum,
    codeId,
    creator,
    ipfsHash,
    name,
    version
  }: {
    checksum: string;
    codeId: number;
    creator: string;
    ipfsHash: string;
    name: string;
    version: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unregisterPlugin: ({
    id
  }: {
    id: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updatePlugin: ({
    checksum,
    codeId,
    creator,
    id,
    ipfsHash,
    name,
    version
  }: {
    checksum?: string;
    codeId?: number;
    creator?: string;
    id: number;
    ipfsHash?: string;
    name?: string;
    version?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateRegistryFee: ({
    newFee
  }: {
    newFee: Coin;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateDaoAddr: ({
    newAddr
  }: {
    newAddr: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class 98Client extends 98QueryClient implements 98Interface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.proxyInstallPlugin = this.proxyInstallPlugin.bind(this);
    this.registerPlugin = this.registerPlugin.bind(this);
    this.unregisterPlugin = this.unregisterPlugin.bind(this);
    this.updatePlugin = this.updatePlugin.bind(this);
    this.updateRegistryFee = this.updateRegistryFee.bind(this);
    this.updateDaoAddr = this.updateDaoAddr.bind(this);
  }

  proxyInstallPlugin = async ({
    id,
    instantiateMsg
  }: {
    id: number;
    instantiateMsg: Binary;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      proxy_install_plugin: {
        id,
        instantiate_msg: instantiateMsg
      }
    }, fee, memo, _funds);
  };
  registerPlugin = async ({
    checksum,
    codeId,
    creator,
    ipfsHash,
    name,
    version
  }: {
    checksum: string;
    codeId: number;
    creator: string;
    ipfsHash: string;
    name: string;
    version: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_plugin: {
        checksum,
        code_id: codeId,
        creator,
        ipfs_hash: ipfsHash,
        name,
        version
      }
    }, fee, memo, _funds);
  };
  unregisterPlugin = async ({
    id
  }: {
    id: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unregister_plugin: {
        id
      }
    }, fee, memo, _funds);
  };
  updatePlugin = async ({
    checksum,
    codeId,
    creator,
    id,
    ipfsHash,
    name,
    version
  }: {
    checksum?: string;
    codeId?: number;
    creator?: string;
    id: number;
    ipfsHash?: string;
    name?: string;
    version?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_plugin: {
        checksum,
        code_id: codeId,
        creator,
        id,
        ipfs_hash: ipfsHash,
        name,
        version
      }
    }, fee, memo, _funds);
  };
  updateRegistryFee = async ({
    newFee
  }: {
    newFee: Coin;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_registry_fee: {
        new_fee: newFee
      }
    }, fee, memo, _funds);
  };
  updateDaoAddr = async ({
    newAddr
  }: {
    newAddr: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_dao_addr: {
        new_addr: newAddr
      }
    }, fee, memo, _funds);
  };
}